// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.28/esri/copyright.txt for details.
//>>built
define("exports ../../core/Error ../../core/has ../../core/mathUtils ./checkWebGLError ./contextUtils ./enums ./GLObjectType ./TextureDescriptor ./ValidatedTextureDescriptor".split(" "),function(B,n,N,F,x,y,e,J,K,L){function C(a,b){(null!=b.width&&0>b.width||null!=b.height&&0>b.height||null!=b.depth&&0>b.depth)&&console.error("Negative dimension parameters are not allowed!");(a=a.type===y.ContextType.WEBGL2)||!b.isImmutable&&!v(b.target)||console.error("Immutable and 3D-like textures are not supported in WebGL1!");
a||null!=b.width&&F.isPowerOfTwo(b.width)&&null!=b.height&&F.isPowerOfTwo(b.height)||("number"===typeof b.wrapMode?b.wrapMode!==e.TextureWrapMode.CLAMP_TO_EDGE&&console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"):(b.wrapMode.s!==e.TextureWrapMode.CLAMP_TO_EDGE||b.wrapMode.t!==e.TextureWrapMode.CLAMP_TO_EDGE)&&console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"),b.hasMipmap&&console.error("Mipmapping requires power-of-two textures!"))}function G(a,
b){let c=b.samplingMode,d=b.samplingMode;if(c===e.TextureSamplingMode.LINEAR_MIPMAP_NEAREST||c===e.TextureSamplingMode.LINEAR_MIPMAP_LINEAR)c=e.TextureSamplingMode.LINEAR,b.hasMipmap||(d=e.TextureSamplingMode.LINEAR);else if(c===e.TextureSamplingMode.NEAREST_MIPMAP_NEAREST||c===e.TextureSamplingMode.NEAREST_MIPMAP_LINEAR)c=e.TextureSamplingMode.NEAREST,b.hasMipmap||(d=e.TextureSamplingMode.NEAREST);a.texParameteri(b.target,a.TEXTURE_MAG_FILTER,c);a.texParameteri(b.target,a.TEXTURE_MIN_FILTER,d)}function H(a,
b){"number"===typeof b.wrapMode?(a.texParameteri(b.target,a.TEXTURE_WRAP_S,b.wrapMode),a.texParameteri(b.target,a.TEXTURE_WRAP_T,b.wrapMode)):(a.texParameteri(b.target,a.TEXTURE_WRAP_S,b.wrapMode.s),a.texParameteri(b.target,a.TEXTURE_WRAP_T,b.wrapMode.t))}function M(a,b){const c=a.capabilities.textureFilterAnisotropic;c&&a.gl.texParameterf(b.target,c.TEXTURE_MAX_ANISOTROPY,b.maxAnisotropy??1)}function z(a){return null!=a&&"type"in a&&"compressed"===a.type}function D(a){return null!=a&&!z(a)&&!(null!=
a&&"byteLength"in a)}function v(a){return a===e.TextureType.TEXTURE_3D||a===e.TextureType.TEXTURE_2D_ARRAY}function I(a,b,c,d=1){b=Math.max(b,c);a===e.TextureType.TEXTURE_3D&&(b=Math.max(b,d));return Math.round(Math.log(b)/Math.LN2)+1}let r=class{constructor(a,b=null,c=null){this.type=J.GLObjectType.Texture;this._glName=null;this._wasImmutablyAllocated=this._wrapModeDirty=this._samplingModeDirty=!1;if("context"in a)this._descriptor=a,c=b;else{a=L.ValidatedTextureDescriptor.validate(a,b);if(!a)throw new n("Texture descriptor invalid");
this._descriptor=a}if(this._descriptor.context.type!==y.ContextType.WEBGL2&&(this._descriptor.isImmutable&&(this._descriptor.isImmutable=!1),v(this._descriptor.target)))throw new n("3D and array textures are not supported in WebGL1");this._descriptor.target===e.TextureType.TEXTURE_CUBE_MAP?this._setDataCubeMap(c):this.setData(c)}get glName(){return this._glName}get descriptor(){return this._descriptor}get gpuMemoryUsage(){A.delete(this);return K.estimateMemory(this._descriptor)}get isDirty(){return this._samplingModeDirty||
this._wrapModeDirty}dispose(){this._glName&&this._descriptor.context.instanceCounter.decrement(e.ResourceType.Texture,this);this._descriptor.context.gl&&this._glName&&(this._descriptor.context.unbindTexture(this),this._descriptor.context.gl.deleteTexture(this._glName),this._glName=null)}release(){this.dispose()}resize(a,b){const c=this._descriptor;if(c.width!==a||c.height!==b){if(this._wasImmutablyAllocated)throw new n("Immutable textures can't be resized!");c.width=a;c.height=b;this._descriptor.target===
e.TextureType.TEXTURE_CUBE_MAP?this._setDataCubeMap(null):this.setData(null)}}_setDataCubeMap(a=null){for(let b=e.TextureType.TEXTURE_CUBE_MAP_POSITIVE_X;b<=e.TextureType.TEXTURE_CUBE_MAP_NEGATIVE_Z;b++)this._setData(a,b)}setData(a){this._setData(a)}_setData(a,b){if(this._descriptor.context?.gl){var c=this._descriptor.context.gl;x.checkWebGLError(c);this._glName||(this._glName=c.createTexture())&&this._descriptor.context.instanceCounter.increment(e.ResourceType.Texture,this);void 0===a&&(a=null);
var d=this._descriptor,f=b??d.target,g=v(f);null===a&&(d.width=d.width||4,d.height=d.height||4,g&&(d.depth=d.depth??1));b=this._descriptor.context.bindTexture(this,r.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(r.TEXTURE_UNIT_FOR_UPDATES);C(this._descriptor.context,d);this._configurePixelStorage();x.checkWebGLError(c);var h=this._deriveInternalFormat();if(D(a)){let k="width"in a?a.width:a.codedWidth,l="height"in a?a.height:a.codedHeight;a instanceof HTMLVideoElement&&(k=a.videoWidth,
l=a.videoHeight);d.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(f,h,d.hasMipmap,k,l,1);this._texImage(f,0,h,k,l,1,a);x.checkWebGLError(c);d.hasMipmap&&this.generateMipmap();d.width||(d.width=k);d.height||(d.height=l);g&&!d.depth&&(d.depth=1)}else{const {width:k,height:l,depth:m}=d;if(null==k||null==l)throw new n("Width and height must be specified!");if(g&&null==m)throw new n("Depth must be specified!");d.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(f,h,d.hasMipmap,k,
l,m);if(z(a)){const p=a.levels;a=I(f,k,l,m);g=Math.min(a-1,p.length-1);null!=this._descriptor.context.gl2?c.texParameteri(d.target,this._descriptor.context.gl2.TEXTURE_MAX_LEVEL,g):d.hasMipmap=d.hasMipmap&&a===p.length;if(!(h in e.CompressedTextureFormat))throw new n("Attempting to use compressed data with an uncompressed format!");this._forEachMipmapLevel((q,u,t,w)=>{this._compressedTexImage(f,q,h,u,t,w,p[Math.min(q,p.length-1)])},g)}else this._texImage(f,0,h,k,l,m,a),x.checkWebGLError(c),d.hasMipmap&&
this.generateMipmap()}G(c,this._descriptor);H(c,this._descriptor);M(this._descriptor.context,this._descriptor);x.checkWebGLError(c);this._descriptor.context.bindTexture(b,r.TEXTURE_UNIT_FOR_UPDATES)}}updateData(a,b,c,d,f,g,h=0){g||console.error("An attempt to use uninitialized data!");this._glName||console.error("An attempt to update uninitialized texture!");const k=this._descriptor.context.gl,l=this._descriptor.context.gl2,m=this._descriptor,p=this._deriveInternalFormat(),{pixelFormat:q,dataType:u,
target:t,isImmutable:w}=m;if(w&&!this._wasImmutablyAllocated)throw new n("Cannot update immutable texture before allocation!");const E=this._descriptor.context.bindTexture(this,r.TEXTURE_UNIT_FOR_UPDATES,!0);(0>b||0>c||d>m.width||f>m.height||b+d>m.width||c+f>m.height)&&console.error("An attempt to update out of bounds of the texture!");this._configurePixelStorage();if(h){if(!l){console.error("Webgl2 must be enabled to use dataRowOffset!");return}k.pixelStorei(l.UNPACK_SKIP_ROWS,h)}D(g)?l?l.texSubImage2D(t,
a,b,c,d,f,q,u,g):k.texSubImage2D(t,a,b,c,q,u,g):z(g)?k.compressedTexSubImage2D(t,a,b,c,d,f,p,g.levels[a]):k.texSubImage2D(t,a,b,c,d,f,q,u,g);if(h){if(!l){console.error("Webgl2 must be enabled to use dataRowOffset!");return}k.pixelStorei(l.UNPACK_SKIP_ROWS,0)}this._descriptor.context.bindTexture(E,r.TEXTURE_UNIT_FOR_UPDATES)}updateData3D(a,b,c,d,f,g,h,k){k||console.error("An attempt to use uninitialized data!");this._glName||console.error("An attempt to update uninitialized texture!");const l=this._descriptor.context.gl2;
if(null==l)throw new n("3D textures are not supported in WebGL1");const m=this._descriptor,p=this._deriveInternalFormat(),{pixelFormat:q,dataType:u,isImmutable:t,target:w}=m;if(t&&!this._wasImmutablyAllocated)throw new n("Cannot update immutable texture before allocation!");v(w)||console.warn("Attempting to set 3D texture data on a non-3D texture");const E=this._descriptor.context.bindTexture(this,r.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(r.TEXTURE_UNIT_FOR_UPDATES);(0>
b||0>c||0>d||f>m.width||g>m.height||h>m.depth||b+f>m.width||c+g>m.height||d+h>m.depth)&&console.error("An attempt to update out of bounds of the texture!");this._configurePixelStorage();z(k)?(k=k.levels[a],l.compressedTexSubImage3D(w,a,b,c,d,f,g,h,p,k)):l.texSubImage3D(w,a,b,c,d,f,g,h,q,u,k);this._descriptor.context.bindTexture(E,r.TEXTURE_UNIT_FOR_UPDATES)}generateMipmap(){const a=this._descriptor;if(!a.hasMipmap){if(this._wasImmutablyAllocated)throw new n("Cannot add mipmaps to immutable texture after allocation");
this._samplingModeDirty=a.hasMipmap=!0;C(this._descriptor.context,a)}a.samplingMode===e.TextureSamplingMode.LINEAR?(this._samplingModeDirty=!0,a.samplingMode=e.TextureSamplingMode.LINEAR_MIPMAP_NEAREST):a.samplingMode===e.TextureSamplingMode.NEAREST&&(this._samplingModeDirty=!0,a.samplingMode=e.TextureSamplingMode.NEAREST_MIPMAP_NEAREST);const b=this._descriptor.context.bindTexture(this,r.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(r.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.gl.generateMipmap(a.target);
this._descriptor.context.bindTexture(b,r.TEXTURE_UNIT_FOR_UPDATES)}setSamplingMode(a){a!==this._descriptor.samplingMode&&(this._descriptor.samplingMode=a,this._samplingModeDirty=!0)}setWrapMode(a){a!==this._descriptor.wrapMode&&(this._descriptor.wrapMode=a,C(this._descriptor.context,this._descriptor),this._wrapModeDirty=!0)}applyChanges(){const a=this._descriptor.context.gl,b=this._descriptor;this._samplingModeDirty&&(G(a,b),this._samplingModeDirty=!1);this._wrapModeDirty&&(H(a,b),this._wrapModeDirty=
!1)}_deriveInternalFormat(){if(this._descriptor.context.type===y.ContextType.WEBGL1)return this._descriptor.internalFormat=this._descriptor.pixelFormat;if(null!=this._descriptor.internalFormat)return this._descriptor.internalFormat===e.PixelFormat.DEPTH_STENCIL&&(this._descriptor.internalFormat=e.PixelFormat.DEPTH24_STENCIL8),this._descriptor.internalFormat;switch(this._descriptor.dataType){case e.PixelType.FLOAT:switch(this._descriptor.pixelFormat){case e.PixelFormat.RGBA:return this._descriptor.internalFormat=
e.SizedPixelFormat.RGBA32F;case e.PixelFormat.RGB:return this._descriptor.internalFormat=e.SizedPixelFormat.RGB32F;default:throw new n("Unable to derive format");}case e.PixelType.UNSIGNED_BYTE:switch(this._descriptor.pixelFormat){case e.PixelFormat.RGBA:return this._descriptor.internalFormat=e.SizedPixelFormat.RGBA8;case e.PixelFormat.RGB:return this._descriptor.internalFormat=e.SizedPixelFormat.RGB8}}return this._descriptor.internalFormat=this._descriptor.pixelFormat===e.PixelFormat.DEPTH_STENCIL?
e.PixelFormat.DEPTH24_STENCIL8:this._descriptor.pixelFormat}_configurePixelStorage(){const a=this._descriptor.context.gl,{unpackAlignment:b,flipped:c,preMultiplyAlpha:d}=this._descriptor;a.pixelStorei(a.UNPACK_ALIGNMENT,b);a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL,c?1:0);a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL,d?1:0)}_texStorage(a,b,c,d,f,g){const h=this._descriptor.context.gl2;if(null==h)throw new n("Immutable textures are not supported in WebGL1");if(!(b in e.SizedPixelFormat))throw new n("Immutable textures must have a sized internal format");
if(this._descriptor.isImmutable){c=c?I(a,d,f,g):1;if(v(a)){if(null==g)throw new n("Missing depth dimension for 3D texture upload");h.texStorage3D(a,c,b,d,f,g)}else h.texStorage2D(a,c,b,d,f);this._wasImmutablyAllocated=!0}}_texImage(a,b,c,d,f,g,h){const k=this._descriptor.context.gl,l=v(a),{isImmutable:m,pixelFormat:p,dataType:q}=this._descriptor,u=this._descriptor.context.type===y.ContextType.WEBGL2,t=u?k:null;if(!u&&D(h))k.texImage2D(a,0,c,p,q,h);else if(m){if(null!=h)if(l){if(null==g)throw new n("Missing depth dimension for 3D texture upload");
t.texSubImage3D(a,b,0,0,0,d,f,g,p,q,h)}else k.texSubImage2D(a,b,0,0,d,f,p,q,h)}else if(l){if(null==g)throw new n("Missing depth dimension for 3D texture upload");t.texImage3D(a,b,c,d,f,g,0,p,q,h)}else k.texImage2D(a,b,c,d,f,0,p,q,h)}_compressedTexImage(a,b,c,d,f,g,h){const k=this._descriptor.context.gl;let l=null;const m=v(a),p=this._descriptor.isImmutable;if(m){if(this._descriptor.context.type!==y.ContextType.WEBGL2)throw new n("3D textures are not supported in WebGL1");l=k}if(p){if(null!=h)if(m){if(null==
g)throw new n("Missing depth dimension for 3D texture upload");l.compressedTexSubImage3D(a,b,0,0,0,d,f,g,c,h)}else k.compressedTexSubImage2D(a,b,0,0,d,f,c,h)}else if(m){if(null==g)throw new n("Missing depth dimension for 3D texture upload");l.compressedTexImage3D(a,b,c,d,f,g,0,h)}else k.compressedTexImage2D(a,b,c,d,f,0,h)}_forEachMipmapLevel(a,b=Infinity){let {width:c,height:d,depth:f,hasMipmap:g,target:h}=this._descriptor;const k=h===e.TextureType.TEXTURE_3D;if(null==c||null==d||k&&null==f)throw new n("Missing texture dimensions for mipmap calculation");
for(let l=0;;++l){a(l,c,d,f);if(!g||1===c&&1===d&&(!k||1===f)||l>=b)break;c=Math.max(1,c>>1);d=Math.max(1,d>>1);k&&(f=Math.max(1,f>>1))}}};r.TEXTURE_UNIT_FOR_UPDATES=0;const A=new Map;B.Texture=r;B.clearUnestimatedTextures=function(){if(0!==A.size){var a=[];A.forEach((b,c)=>a.push([c.gpuMemoryUsage,b]));A.clear();a.sort((b,c)=>c[0]-b[0]);return a.reduce((b,c)=>`${b}\n\n${Math.round(c[0]/1024)}KB: ${c[1]}`,`Total unestimated texture memory: ${Math.round(a.reduce((b,c)=>b+c[0],0)/1024)}KB`)}};Object.defineProperty(B,
Symbol.toStringTag,{value:"Module"})});