// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.28/esri/copyright.txt for details.
//>>built
define("../../../../../core/Logger ../../../../../core/maybe ../enums ../VertexStream ./WGLGeometryBrushMarker ../effects/Effect ../techniques/utils ../../../../webgl/contextUtils ../../../../webgl/enums ../../../../webgl/FramebufferObject ../../../../webgl/heatmapTextureUtils ../../../../webgl/Renderbuffer ../../../../webgl/RenderbufferDescriptor ../../../../webgl/Texture ../../../../webgl/TextureDescriptor".split(" "),function(w,q,x,y,z,A,r,B,g,C,D,E,F,G,t){function u(b,a){const {referenceScale:c,
radius:e}=b;return e*(0!==c?c/a.scale:1)}const v=w.getLogger("esri.views.2d.engine.webgl.brushes.WGLBrushHeatmap");class H extends z{constructor(){super(...arguments);this.brushEffect=new I}supportsSymbology(b){return b===x.WGLSymbologyType.HEATMAP}dispose(){super.dispose();this.brushEffect.dispose();this.brushEffect=null}prepareState(){}drawGeometry(b,a,c,e){const {defines:f}=this.brushEffect.loadQualityProfile(b.context);super.drawGeometry(b,a,c,e?[...e,...f]:f)}_drawMarkers(b,a,c,e,f,d,k){const {context:m,
rendererInfo:n,state:l}=b;({rendererSchema:b}=n);r.assertRendererSchema(b,"heatmap");const {isFieldActive:p}=b;c.setUniform1f("u_radius",u(b,l));k||(c.setUniform1f("u_isFieldActive",p),m.setStencilFunction(g.CompareFunction.GEQUAL,a.stencilRef,255));m.drawElements(e,f,g.DataType.UNSIGNED_INT,d)}}const J={vsPath:"heatmap/heatmapResolve",fsPath:"heatmap/heatmapResolve",attributes:new Map([["a_position",0]])};class I extends A.Effect{constructor(){super(...arguments);this.name=this.constructor.name}createOptions({passOptions:b}){return b}dispose(){this._prevFBO=
null;null!=this._accumulateFramebuffer&&this._accumulateFramebuffer.detachDepthStencilBuffer();this._accumulateOutputStencilBuffer=q.disposeMaybe(this._accumulateOutputStencilBuffer);this._accumulateFramebuffer=q.disposeMaybe(this._accumulateFramebuffer);this._resolveGradientTexture=q.disposeMaybe(this._resolveGradientTexture);this._tileQuad=q.disposeMaybe(this._tileQuad)}bind(b){const {context:a,rendererInfo:c,passOptions:e,state:f}=b,{rendererSchema:d}=c;null!=e&&"hittest"===e.type||"heatmap"!==
d.type||(this._prevFBO=a.getBoundFramebufferObject(),this._prevViewport=a.getViewport(),r.assertRendererSchema(d,"heatmap"),this._loadResources(b),this._updateResources(a,d,f),a.bindFramebuffer(this._accumulateFramebuffer),a.setViewport(0,0,this._accumulateFramebuffer.width,this._accumulateFramebuffer.height),a.setStencilTestEnabled(!0),a.setBlendingEnabled(!0),a.setBlendFunction(g.BlendFactor.ONE,g.BlendFactor.ONE),a.setClearColor(0,0,0,0),a.clear(g.ClearBufferBit.COLOR_BUFFER_BIT))}unbind(){this._prevViewport=
this._prevFBO=null}draw(b){const {context:a,painter:c,rendererInfo:e,passOptions:f}=b;({rendererSchema:b}=e);if((null==f||"hittest"!==f.type)&&"heatmap"===b.type){var {defines:d}=this.loadQualityProfile(a);d=c.materialManager.getProgram(J,d);a.useProgram(d);a.bindFramebuffer(this._prevFBO);a.setViewport(0,0,this._prevViewport.width,this._prevViewport.height);a.setBlendFunction(g.BlendFactor.ONE,g.BlendFactor.ONE_MINUS_SRC_ALPHA);a.setStencilTestEnabled(!1);var {radius:k,minDensity:m,densityRange:n}=
b;a.bindTexture(this._accumulateFramebuffer.colorTexture,8);a.bindTexture(this._resolveGradientTexture,9);d.setUniform1i("u_texture",8);d.setUniform1i("u_gradient",9);d.setUniform2f("u_densityMinAndInvRange",m,1/n);d.setUniform1f("u_densityNormalization",3/(k*k*Math.PI));this._tileQuad.draw()}}_loadResources({context:b,painter:a}){const {dataType:c,samplingMode:e,pixelFormat:f,internalFormat:d,requiresSharedStencilBuffer:k}=this.loadQualityProfile(b),{width:m,height:n}=this._prevViewport;var l=k?
1:.25;const p=m*l;l*=n;let h=new t.TextureDescriptor(p,l);h.pixelFormat=f;h.internalFormat=d;h.dataType=c;h.samplingMode=e;h.wrapMode=g.TextureWrapMode.CLAMP_TO_EDGE;k||(this._accumulateOutputStencilBuffer??(this._accumulateOutputStencilBuffer=new E.Renderbuffer(b,new F.RenderbufferDescriptor(g.RenderbufferFormat.DEPTH_STENCIL,p,l))));this._accumulateFramebuffer??(this._accumulateFramebuffer=new C.FramebufferObject(b,h,k?a.getSharedStencilBuffer():this._accumulateOutputStencilBuffer));h=new t.TextureDescriptor;
h.wrapMode=g.TextureWrapMode.CLAMP_TO_EDGE;this._resolveGradientTexture??(this._resolveGradientTexture=new G.Texture(b,h));this._tileQuad??(this._tileQuad=new y(b,[0,0,1,0,0,1,1,1]))}_updateResources(b,a,c){const {gradientHash:e,gradient:f}=a;this._prevGradientHash!==e&&(this._resolveGradientTexture.resize(f.length/4,1),this._resolveGradientTexture.setData(f),this._prevGradientHash=e);const {requiresSharedStencilBuffer:d}=this.loadQualityProfile(b);c=d?1:2>u(a,c)?1:.25;const {width:k,height:m}=this._prevViewport;
a=k*c;c*=m;const {width:n,height:l}=this._accumulateFramebuffer;if(n!==a||l!==c){const p=this._accumulateFramebuffer.depthStencil;if(d&&null!=p){const {width:h,height:K}=p.descriptor;if(h!==a||K!==c)v.errorOnce("Attempted to resize shared stencil buffer! Detaching instead."),this._accumulateFramebuffer.detachDepthStencilBuffer()}this._accumulateFramebuffer.resize(a,c)}d||b.blitFramebuffer(this._prevFBO,this._accumulateFramebuffer,0,0,this._prevFBO.width,this._prevFBO.height,0,0,this._accumulateFramebuffer.width,
this._accumulateFramebuffer.height,g.ClearBufferBit.STENCIL_BUFFER_BIT,g.TextureSamplingMode.NEAREST)}loadQualityProfile(b){if(null==this._qualityProfile){const a=D.loadHeatmapTextureConfiguration(b,v);this._qualityProfile={...a,requiresSharedStencilBuffer:b.type===B.ContextType.WEBGL1,defines:a.dataType!==g.PixelType.FLOAT?["heatmapPrecisionHalfFloat"]:[]}}return this._qualityProfile}}return H});